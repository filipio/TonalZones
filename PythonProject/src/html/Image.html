<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>Image API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Image</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import cv2 as cv
from PyQt5.QtGui import QImage
from PyQt5 import QtGui
from PyQt5.QtWidgets import (QFileDialog,QMessageBox)
import numpy as np
from Bilateral import Bilateral
from Avaraging import Avaraging
from Gaussian import Gaussian
from Median import Median
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtCore import QObject
from Enums import *
from Mask import Mask
from Thresold import Thresold
from copy import deepcopy

class Image(QObject):
    &#34;&#34;&#34;
    Image is a class responsible for doing operations on an image. Class should be initialized when
    new image from file is required. Every operation that is operating on an image should be contained
    in this class.
    Insert necessery methods below.
    &#34;&#34;&#34;
    pixel_selected = pyqtSignal(int)
    img_loaded = pyqtSignal()
    thresh_val_calc = pyqtSignal(int)
    mask_loaded = pyqtSignal(Mask)
    mask_saved = pyqtSignal(str)
    def __init__(self, graphic_area, default_mask_name):
        super().__init__(None)
        self.default_mask_name = default_mask_name
        self.image = np.empty(0)
        self.tmp_image = np.empty(0)
        self.thresholded_pixels = np.empty(0) 
        self.mask_belongings = np.empty(0)
        self.mask_copy=np.empty(0) # name should be changed
        self.graphic_area = graphic_area
        self.Bilateral=Bilateral()
        self.Avaraging=Avaraging(self.graphic_area)
        self.Gaussian=Gaussian(self.graphic_area)
        self.Median=Median()
        self.active_mask = None
        self.masks = {}
        self.masks_mapping = {}
        self.Otsu=Thresold()
        self.latest_img=None#latest image 
    def _show_img(self, frame):
        &#34;&#34;&#34;
        function to show image represented by the frame.
        &#34;&#34;&#34;
        img_rep = QImage(frame, frame.shape[1], frame.shape[0], frame.strides[0], QImage.Format.Format_RGB888)
        self.graphic_area.setPixmap(QtGui.QPixmap.fromImage(img_rep))

    def _update_img(self, img, save=True):
        &#34;&#34;&#34;
        function to display and save new state of image.
        &#34;&#34;&#34;
        self.tmp_image = img
        frame = cv.cvtColor(img, cv.COLOR_BGR2RGB)
        self._show_img(frame)


    def _empty_img_error(self):
        &#34;&#34;&#34;
        function to check whether any image was loaded 
        and display appropriate message to user.
        &#34;&#34;&#34;
        if self.tmp_image.size == 0: 
            msg_box = QMessageBox.about(self.graphic_area,&#34;Error&#34;,&#34;Image needs to be loaded first.&#34;)
            return True
        return False

    def _ratio_to_img(self):
        &#34;&#34;&#34;
        function to get the ratio between real image and screen image.
        &#34;&#34;&#34;
        img_height = self.image.shape[0]
        img_width = self.image.shape[1]  
        return (img_width / self.graphic_area.width(), img_height / self.graphic_area.height())

    def _transform_pixel_to_img(self, index_x, index_y):
        &#34;&#34;&#34;
        function to map pixel where user clicked on the screen-image to real image.
        &#34;&#34;&#34;
        x_ratio , y_ratio = self._ratio_to_img()
        return (int(index_x * x_ratio), int(index_y * y_ratio))

    def _create_mask_img(self, rows, columns, color):
        &#34;&#34;&#34;
        function to create what needs to be displayed based on parameters:
        rows and columns contain indexes where pixel of given color should be placed.
        The rest of pixels are the same as in current image.
        &#34;&#34;&#34;
        mask_img = cv.cvtColor(self.tmp_image, cv.COLOR_GRAY2RGB)
        mask_img[rows, columns, :] = 0
        mask_img[rows, columns, color] = MaskColor.FILL
        return mask_img

    def _get_mask(self, m_id):
        &#34;&#34;&#34;
        function to get mask by it&#39;s id.
        &#34;&#34;&#34;
        return self.masks.get(self.masks_mapping.get(m_id))

    def _update_masks_data(self, prev_mask_values):
        &#34;&#34;&#34;
        function which saves information about pixels that current mask owns.
        If current mask is in read-state, every pixel that which belonged to some mask (prev_owner_mask)
        and now belongs to current mask changes its owner. User is notified if such event takes place.
        &#34;&#34;&#34;
        if self.active_mask.is_read and self.active_mask.saved:
            active_mask_values = self.active_mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels)
            to_remove_rows, to_remove_columns = np.where((prev_mask_values == True) &amp; (active_mask_values == False))
            self.mask_belongings[to_remove_rows, to_remove_columns] = MaskBelonging.NONE
            occupied_rows, occupied_columns = np.where((active_mask_values == True) &amp; (self.mask_belongings != self.active_mask.id) &amp; (self.mask_belongings &gt;= 0)) 
            if len(occupied_rows) &gt; 0:
                QMessageBox.information(self.graphic_area, &#34;Masks modified&#34;,
                 &#34;Your modification will remove some pixels from other masks.&#34;)
            for i in range(len(occupied_rows)):
                prev_owner_mask = self._get_mask(self.mask_belongings[occupied_rows[i], occupied_columns[i]])
                assert prev_owner_mask.id == self.mask_belongings[occupied_rows[i], occupied_columns[i]]
                prev_owner_mask.remove(occupied_rows[i], occupied_columns[i])
            self.mask_belongings[active_mask_values] = self.active_mask.id
            self._update_all_masks()

    def _update_all_masks(self, update_threshold=False):
        for name, mask in self.masks.items():
            if name != self.default_mask_name:
                self.mask_belongings[mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels)] = mask.id
            if update_threshold:
                mask.is_thresholded = False

    def save(self):
        &#34;&#34;&#34;
        function to save current image. If not every pixel was thresholded, question
        occurs whether user wants to continue.
        &#34;&#34;&#34;
        if not self._empty_img_error():
            if not np.all(self.thresholded_pixels):
                reply = QMessageBox.question(self.graphic_area, &#34;Work not finished&#34;, &#34;Are you sure you want to save the image ? Some pixels haven&#39;t been thresholded yet.&#34;)
                if reply == QMessageBox.Yes:
                    destination = QFileDialog.getSaveFileName(filter=&#34;Image (*.jpg *.png)&#34;)[0]
                    cv.imwrite(destination,self.tmp_image)        
            else:
                destination = QFileDialog.getSaveFileName(filter=&#34;Image (*.jpg *.png)&#34;)[0]
                cv.imwrite(destination,self.tmp_image)

    def load(self):
        &#34;&#34;&#34;
        function to load an image from destination and reset some Image object values
        &#34;&#34;&#34;
        file_name = QFileDialog.getOpenFileName(None, &#34;Open File&#34;, &#34;/home&#34;, &#34;Images (*.png *.xpm *.jpg)&#34;)[0]
        if file_name:
            self.graphic_area.setScaledContents(True)
            self.image = cv.imread(file_name, cv.IMREAD_GRAYSCALE)
            self.thresholded_pixels = np.full((self.image.shape[0], self.image.shape[1]), False, dtype=bool)
            self.mask_belongings = np.full((self.image.shape[0], self.image.shape[1]), MaskBelonging.NONE, dtype=int)
            self.tmp_image = self.image
            self._update_img(self.image)
            if not self.masks:
                self.new_mask()
            else:
                self._update_all_masks(update_threshold=True)
                self.show_curr_mask()
            # was call to new here
            self.img_loaded.emit()


    def show_curr_mask(self, modified = True):
        &#34;&#34;&#34;
        function to show the current mask = last that was applied
        &#34;&#34;&#34;
        red_rows, red_columns = np.where(self.active_mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels, modified) == False)
        mask_img = self._create_mask_img(red_rows, red_columns, MaskColor.RED)
        self._show_img(mask_img)

    def show_curr_img(self):
        &#34;&#34;&#34;
        function to show curr img
        &#34;&#34;&#34;
        frame = cv.cvtColor(self.tmp_image, cv.COLOR_BGR2RGB)
        self._show_img(frame)

    def save_mask(self, name):
        &#34;&#34;&#34;
        function to save curr mask as a given name. If the name was provided before, warning occurs.
        &#34;&#34;&#34;
        if name in self.masks.keys():
            QMessageBox.warning(self.graphic_area,&#34;Error&#34;,&#34;Mask with such name already exist.&#34;)
        else:
            self.mask_belongings[self.active_mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels)] = self.active_mask.id
            self.masks_mapping[self.active_mask.id] = name
            self.masks[name] = self.active_mask
            self.active_mask.saved = True
            self.mask_saved.emit(name)
            
            
 
    def new_mask(self):
        &#34;&#34;&#34;
        function to create a new mask.
        &#34;&#34;&#34;
        if self.active_mask:
            self.active_mask.is_read = False
        self.active_mask = Mask(self.image.shape[0], self.image.shape[1])
        self.masks[self.default_mask_name] = self.active_mask
        self.mask_loaded.emit(self.active_mask)
        self.show_curr_img()

    def load_mask(self, name):
        &#34;&#34;&#34;
        function to load mask given by name. Some values are reset in case new image was loaded.
        &#34;&#34;&#34;
        self.active_mask.is_read = False
        self.active_mask = self.masks.get(name)
        self.active_mask.loaded_handler()
        self.mask_loaded.emit(self.active_mask)
        self.show_curr_mask()
        if(not self.active_mask.new):
            self.active_mask.is_read = True
        

    def delete_mask(self, name):
        &#34;&#34;&#34;
        function to delete mask given by name.
        &#34;&#34;&#34;
        default_mask = self.masks[self.default_mask_name]
        if self.active_mask == default_mask:
            default_mask = deepcopy(self.active_mask)
            default_mask.saved = False
            self.masks[self.default_mask_name] = default_mask
            
        self.mask_belongings[self.active_mask.get(modified=False)] = MaskBelonging.NONE
        self.masks.pop(name)
        self.masks_mapping.pop(self.active_mask.id)
        self._update_all_masks()


    def pop_mask_pixel(self):
        &#34;&#34;&#34;
        function to pop a pixel from a current mask pixel list.
        &#34;&#34;&#34;
        
        try : 
            prev_mask = self.active_mask.get(modified=False)
            self.active_mask.pop_pixel()
            self.apply_mask(prev_mask)
        except IndexError as err:
            QMessageBox.information(self.graphic_area, &#34;Error&#34;,  err.args[0])
        except AttributeError as err:
            QMessageBox.information(self.graphic_area, &#34;Error&#34;, &#34;Mask hasn&#39;t been created yet.&#34;)
        
    
    def update_mask_pixel_tol(self, value):
        &#34;&#34;&#34;
        function to update pixel tolerance in current mask.
        &#34;&#34;&#34;
        prev_mask = self.active_mask.get(modified=False)
        self.active_mask.update_pixel_tol(value)
        self.apply_mask(prev_mask)

    def update_slider_mask(self, s_min, s_max, s_tol):
        prev_mask = self.active_mask.get(modified=False)
        self.active_mask.update_slider_mask(s_min, s_max, s_tol)
        self.apply_mask(prev_mask)

    def not_thresholded_handler(self):
        &#34;&#34;&#34;
        function to show which pixels haven&#39;t been thresholded yet.
        &#34;&#34;&#34;
        blue_x, blue_y = np.where(self.thresholded_pixels == False)
        mask_img = self._create_mask_img(blue_x, blue_y, MaskColor.BLUE)
        self._show_img(mask_img)


    def apply_mask(self, previous_mask):
        &#34;&#34;&#34;
        function to apply mask - it should be called after any change in current mask.
        &#34;&#34;&#34;
        self.active_mask.is_thresholded = False
        self._update_masks_data(previous_mask)
        self.show_curr_mask()


    def pixel_clicked_handler(self, x, y):
        &#34;&#34;&#34;
        function to add pixel to current mask pixel list.
        &#34;&#34;&#34;
        img_x, img_y = self._transform_pixel_to_img(x, y)
        grey_value = self.image[img_y][img_x]
        self.pixel_selected.emit(grey_value)
        self.active_mask.add_pixel(grey_value)
    
    def blur_avg_filter(self):
        &#34;&#34;&#34;
            function to apply averaging filter
        &#34;&#34;&#34;
        self._update_img(self.Avaraging.apply(self.tmp_image))
    
    def blur_bilateral_filter(self):
        &#34;&#34;&#34;
            function to apply bilateral filter
        &#34;&#34;&#34;
        self._update_img(self.Bilateral.apply(self.tmp_image))
    
    def blur_gauss_filter(self):
        &#34;&#34;&#34;
            function to apply gaussian filter
        &#34;&#34;&#34;
        self._update_img(self.Gaussian.apply(self.tmp_image))
    
    def blur_med_filter(self,params_dict):
        &#34;&#34;&#34;
            function to apply median filter
        &#34;&#34;&#34;
        self._update_img(self.Median.apply(self.tmp_image))
    
    def threshold(self,method=&#39;VAL&#39;):
        &#34;&#34;&#34;
            set thresolding to given value
        &#34;&#34;&#34;
        self.mask_copy=np.copy(self.tmp_image)
        indexes_to_thr=np.where(self.active_mask.get(modified=False))
        otsu_res,thres_val=self.Otsu.apply(self.mask_copy[indexes_to_thr],method)
        self.tmp_image[tuple((indexes_to_thr))]=otsu_res.flatten()
        self.latest_img=self.tmp_image.copy()
        self._update_img(self.tmp_image)
        self.thresh_val_calc.emit(thres_val)
        self.tmp_image=self.mask_copy
        
    def apply_threshold(self):
        &#34;&#34;&#34;method to apply thresold to given image&#34;&#34;&#34;
        self.active_mask.is_thresholded = True
        indexes_to_thr=np.where(self.active_mask.get(modified=False))
        self.thresholded_pixels[tuple((indexes_to_thr))] = True
        self._update_img(self.latest_img)

    def remove_threshold(self):
        &#34;&#34;&#34;
            remove thresolding from image, if it have not been applied before
        &#34;&#34;&#34;
        self.thresh_val_calc.emit(0)
        if not self.active_mask.is_thresholded:
            self._update_img(self.mask_copy)
        else:
            self.active_mask.is_thresholded = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Image.Image"><code class="flex name class">
<span>class <span class="ident">Image</span></span>
<span>(</span><span>graphic_area, default_mask_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Image is a class responsible for doing operations on an image. Class should be initialized when
new image from file is required. Every operation that is operating on an image should be contained
in this class.
Insert necessery methods below.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Image(QObject):
    &#34;&#34;&#34;
    Image is a class responsible for doing operations on an image. Class should be initialized when
    new image from file is required. Every operation that is operating on an image should be contained
    in this class.
    Insert necessery methods below.
    &#34;&#34;&#34;
    pixel_selected = pyqtSignal(int)
    img_loaded = pyqtSignal()
    thresh_val_calc = pyqtSignal(int)
    mask_loaded = pyqtSignal(Mask)
    mask_saved = pyqtSignal(str)
    def __init__(self, graphic_area, default_mask_name):
        super().__init__(None)
        self.default_mask_name = default_mask_name
        self.image = np.empty(0)
        self.tmp_image = np.empty(0)
        self.thresholded_pixels = np.empty(0) 
        self.mask_belongings = np.empty(0)
        self.mask_copy=np.empty(0) # name should be changed
        self.graphic_area = graphic_area
        self.Bilateral=Bilateral()
        self.Avaraging=Avaraging(self.graphic_area)
        self.Gaussian=Gaussian(self.graphic_area)
        self.Median=Median()
        self.active_mask = None
        self.masks = {}
        self.masks_mapping = {}
        self.Otsu=Thresold()
        self.latest_img=None#latest image 
    def _show_img(self, frame):
        &#34;&#34;&#34;
        function to show image represented by the frame.
        &#34;&#34;&#34;
        img_rep = QImage(frame, frame.shape[1], frame.shape[0], frame.strides[0], QImage.Format.Format_RGB888)
        self.graphic_area.setPixmap(QtGui.QPixmap.fromImage(img_rep))

    def _update_img(self, img, save=True):
        &#34;&#34;&#34;
        function to display and save new state of image.
        &#34;&#34;&#34;
        self.tmp_image = img
        frame = cv.cvtColor(img, cv.COLOR_BGR2RGB)
        self._show_img(frame)


    def _empty_img_error(self):
        &#34;&#34;&#34;
        function to check whether any image was loaded 
        and display appropriate message to user.
        &#34;&#34;&#34;
        if self.tmp_image.size == 0: 
            msg_box = QMessageBox.about(self.graphic_area,&#34;Error&#34;,&#34;Image needs to be loaded first.&#34;)
            return True
        return False

    def _ratio_to_img(self):
        &#34;&#34;&#34;
        function to get the ratio between real image and screen image.
        &#34;&#34;&#34;
        img_height = self.image.shape[0]
        img_width = self.image.shape[1]  
        return (img_width / self.graphic_area.width(), img_height / self.graphic_area.height())

    def _transform_pixel_to_img(self, index_x, index_y):
        &#34;&#34;&#34;
        function to map pixel where user clicked on the screen-image to real image.
        &#34;&#34;&#34;
        x_ratio , y_ratio = self._ratio_to_img()
        return (int(index_x * x_ratio), int(index_y * y_ratio))

    def _create_mask_img(self, rows, columns, color):
        &#34;&#34;&#34;
        function to create what needs to be displayed based on parameters:
        rows and columns contain indexes where pixel of given color should be placed.
        The rest of pixels are the same as in current image.
        &#34;&#34;&#34;
        mask_img = cv.cvtColor(self.tmp_image, cv.COLOR_GRAY2RGB)
        mask_img[rows, columns, :] = 0
        mask_img[rows, columns, color] = MaskColor.FILL
        return mask_img

    def _get_mask(self, m_id):
        &#34;&#34;&#34;
        function to get mask by it&#39;s id.
        &#34;&#34;&#34;
        return self.masks.get(self.masks_mapping.get(m_id))

    def _update_masks_data(self, prev_mask_values):
        &#34;&#34;&#34;
        function which saves information about pixels that current mask owns.
        If current mask is in read-state, every pixel that which belonged to some mask (prev_owner_mask)
        and now belongs to current mask changes its owner. User is notified if such event takes place.
        &#34;&#34;&#34;
        if self.active_mask.is_read and self.active_mask.saved:
            active_mask_values = self.active_mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels)
            to_remove_rows, to_remove_columns = np.where((prev_mask_values == True) &amp; (active_mask_values == False))
            self.mask_belongings[to_remove_rows, to_remove_columns] = MaskBelonging.NONE
            occupied_rows, occupied_columns = np.where((active_mask_values == True) &amp; (self.mask_belongings != self.active_mask.id) &amp; (self.mask_belongings &gt;= 0)) 
            if len(occupied_rows) &gt; 0:
                QMessageBox.information(self.graphic_area, &#34;Masks modified&#34;,
                 &#34;Your modification will remove some pixels from other masks.&#34;)
            for i in range(len(occupied_rows)):
                prev_owner_mask = self._get_mask(self.mask_belongings[occupied_rows[i], occupied_columns[i]])
                assert prev_owner_mask.id == self.mask_belongings[occupied_rows[i], occupied_columns[i]]
                prev_owner_mask.remove(occupied_rows[i], occupied_columns[i])
            self.mask_belongings[active_mask_values] = self.active_mask.id
            self._update_all_masks()

    def _update_all_masks(self, update_threshold=False):
        for name, mask in self.masks.items():
            if name != self.default_mask_name:
                self.mask_belongings[mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels)] = mask.id
            if update_threshold:
                mask.is_thresholded = False

    def save(self):
        &#34;&#34;&#34;
        function to save current image. If not every pixel was thresholded, question
        occurs whether user wants to continue.
        &#34;&#34;&#34;
        if not self._empty_img_error():
            if not np.all(self.thresholded_pixels):
                reply = QMessageBox.question(self.graphic_area, &#34;Work not finished&#34;, &#34;Are you sure you want to save the image ? Some pixels haven&#39;t been thresholded yet.&#34;)
                if reply == QMessageBox.Yes:
                    destination = QFileDialog.getSaveFileName(filter=&#34;Image (*.jpg *.png)&#34;)[0]
                    cv.imwrite(destination,self.tmp_image)        
            else:
                destination = QFileDialog.getSaveFileName(filter=&#34;Image (*.jpg *.png)&#34;)[0]
                cv.imwrite(destination,self.tmp_image)

    def load(self):
        &#34;&#34;&#34;
        function to load an image from destination and reset some Image object values
        &#34;&#34;&#34;
        file_name = QFileDialog.getOpenFileName(None, &#34;Open File&#34;, &#34;/home&#34;, &#34;Images (*.png *.xpm *.jpg)&#34;)[0]
        if file_name:
            self.graphic_area.setScaledContents(True)
            self.image = cv.imread(file_name, cv.IMREAD_GRAYSCALE)
            self.thresholded_pixels = np.full((self.image.shape[0], self.image.shape[1]), False, dtype=bool)
            self.mask_belongings = np.full((self.image.shape[0], self.image.shape[1]), MaskBelonging.NONE, dtype=int)
            self.tmp_image = self.image
            self._update_img(self.image)
            if not self.masks:
                self.new_mask()
            else:
                self._update_all_masks(update_threshold=True)
                self.show_curr_mask()
            # was call to new here
            self.img_loaded.emit()


    def show_curr_mask(self, modified = True):
        &#34;&#34;&#34;
        function to show the current mask = last that was applied
        &#34;&#34;&#34;
        red_rows, red_columns = np.where(self.active_mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels, modified) == False)
        mask_img = self._create_mask_img(red_rows, red_columns, MaskColor.RED)
        self._show_img(mask_img)

    def show_curr_img(self):
        &#34;&#34;&#34;
        function to show curr img
        &#34;&#34;&#34;
        frame = cv.cvtColor(self.tmp_image, cv.COLOR_BGR2RGB)
        self._show_img(frame)

    def save_mask(self, name):
        &#34;&#34;&#34;
        function to save curr mask as a given name. If the name was provided before, warning occurs.
        &#34;&#34;&#34;
        if name in self.masks.keys():
            QMessageBox.warning(self.graphic_area,&#34;Error&#34;,&#34;Mask with such name already exist.&#34;)
        else:
            self.mask_belongings[self.active_mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels)] = self.active_mask.id
            self.masks_mapping[self.active_mask.id] = name
            self.masks[name] = self.active_mask
            self.active_mask.saved = True
            self.mask_saved.emit(name)
            
            
 
    def new_mask(self):
        &#34;&#34;&#34;
        function to create a new mask.
        &#34;&#34;&#34;
        if self.active_mask:
            self.active_mask.is_read = False
        self.active_mask = Mask(self.image.shape[0], self.image.shape[1])
        self.masks[self.default_mask_name] = self.active_mask
        self.mask_loaded.emit(self.active_mask)
        self.show_curr_img()

    def load_mask(self, name):
        &#34;&#34;&#34;
        function to load mask given by name. Some values are reset in case new image was loaded.
        &#34;&#34;&#34;
        self.active_mask.is_read = False
        self.active_mask = self.masks.get(name)
        self.active_mask.loaded_handler()
        self.mask_loaded.emit(self.active_mask)
        self.show_curr_mask()
        if(not self.active_mask.new):
            self.active_mask.is_read = True
        

    def delete_mask(self, name):
        &#34;&#34;&#34;
        function to delete mask given by name.
        &#34;&#34;&#34;
        default_mask = self.masks[self.default_mask_name]
        if self.active_mask == default_mask:
            default_mask = deepcopy(self.active_mask)
            default_mask.saved = False
            self.masks[self.default_mask_name] = default_mask
            
        self.mask_belongings[self.active_mask.get(modified=False)] = MaskBelonging.NONE
        self.masks.pop(name)
        self.masks_mapping.pop(self.active_mask.id)
        self._update_all_masks()


    def pop_mask_pixel(self):
        &#34;&#34;&#34;
        function to pop a pixel from a current mask pixel list.
        &#34;&#34;&#34;
        
        try : 
            prev_mask = self.active_mask.get(modified=False)
            self.active_mask.pop_pixel()
            self.apply_mask(prev_mask)
        except IndexError as err:
            QMessageBox.information(self.graphic_area, &#34;Error&#34;,  err.args[0])
        except AttributeError as err:
            QMessageBox.information(self.graphic_area, &#34;Error&#34;, &#34;Mask hasn&#39;t been created yet.&#34;)
        
    
    def update_mask_pixel_tol(self, value):
        &#34;&#34;&#34;
        function to update pixel tolerance in current mask.
        &#34;&#34;&#34;
        prev_mask = self.active_mask.get(modified=False)
        self.active_mask.update_pixel_tol(value)
        self.apply_mask(prev_mask)

    def update_slider_mask(self, s_min, s_max, s_tol):
        prev_mask = self.active_mask.get(modified=False)
        self.active_mask.update_slider_mask(s_min, s_max, s_tol)
        self.apply_mask(prev_mask)

    def not_thresholded_handler(self):
        &#34;&#34;&#34;
        function to show which pixels haven&#39;t been thresholded yet.
        &#34;&#34;&#34;
        blue_x, blue_y = np.where(self.thresholded_pixels == False)
        mask_img = self._create_mask_img(blue_x, blue_y, MaskColor.BLUE)
        self._show_img(mask_img)


    def apply_mask(self, previous_mask):
        &#34;&#34;&#34;
        function to apply mask - it should be called after any change in current mask.
        &#34;&#34;&#34;
        self.active_mask.is_thresholded = False
        self._update_masks_data(previous_mask)
        self.show_curr_mask()


    def pixel_clicked_handler(self, x, y):
        &#34;&#34;&#34;
        function to add pixel to current mask pixel list.
        &#34;&#34;&#34;
        img_x, img_y = self._transform_pixel_to_img(x, y)
        grey_value = self.image[img_y][img_x]
        self.pixel_selected.emit(grey_value)
        self.active_mask.add_pixel(grey_value)
    
    def blur_avg_filter(self):
        &#34;&#34;&#34;
            function to apply averaging filter
        &#34;&#34;&#34;
        self._update_img(self.Avaraging.apply(self.tmp_image))
    
    def blur_bilateral_filter(self):
        &#34;&#34;&#34;
            function to apply bilateral filter
        &#34;&#34;&#34;
        self._update_img(self.Bilateral.apply(self.tmp_image))
    
    def blur_gauss_filter(self):
        &#34;&#34;&#34;
            function to apply gaussian filter
        &#34;&#34;&#34;
        self._update_img(self.Gaussian.apply(self.tmp_image))
    
    def blur_med_filter(self,params_dict):
        &#34;&#34;&#34;
            function to apply median filter
        &#34;&#34;&#34;
        self._update_img(self.Median.apply(self.tmp_image))
    
    def threshold(self,method=&#39;VAL&#39;):
        &#34;&#34;&#34;
            set thresolding to given value
        &#34;&#34;&#34;
        self.mask_copy=np.copy(self.tmp_image)
        indexes_to_thr=np.where(self.active_mask.get(modified=False))
        otsu_res,thres_val=self.Otsu.apply(self.mask_copy[indexes_to_thr],method)
        self.tmp_image[tuple((indexes_to_thr))]=otsu_res.flatten()
        self.latest_img=self.tmp_image.copy()
        self._update_img(self.tmp_image)
        self.thresh_val_calc.emit(thres_val)
        self.tmp_image=self.mask_copy
        
    def apply_threshold(self):
        &#34;&#34;&#34;method to apply thresold to given image&#34;&#34;&#34;
        self.active_mask.is_thresholded = True
        indexes_to_thr=np.where(self.active_mask.get(modified=False))
        self.thresholded_pixels[tuple((indexes_to_thr))] = True
        self._update_img(self.latest_img)

    def remove_threshold(self):
        &#34;&#34;&#34;
            remove thresolding from image, if it have not been applied before
        &#34;&#34;&#34;
        self.thresh_val_calc.emit(0)
        if not self.active_mask.is_thresholded:
            self._update_img(self.mask_copy)
        else:
            self.active_mask.is_thresholded = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Image.Image.apply_mask"><code class="name flex">
<span>def <span class="ident">apply_mask</span></span>(<span>self, previous_mask)</span>
</code></dt>
<dd>
<div class="desc"><p>function to apply mask - it should be called after any change in current mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_mask(self, previous_mask):
    &#34;&#34;&#34;
    function to apply mask - it should be called after any change in current mask.
    &#34;&#34;&#34;
    self.active_mask.is_thresholded = False
    self._update_masks_data(previous_mask)
    self.show_curr_mask()</code></pre>
</details>
</dd>
<dt id="Image.Image.apply_threshold"><code class="name flex">
<span>def <span class="ident">apply_threshold</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>method to apply thresold to given image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_threshold(self):
    &#34;&#34;&#34;method to apply thresold to given image&#34;&#34;&#34;
    self.active_mask.is_thresholded = True
    indexes_to_thr=np.where(self.active_mask.get(modified=False))
    self.thresholded_pixels[tuple((indexes_to_thr))] = True
    self._update_img(self.latest_img)</code></pre>
</details>
</dd>
<dt id="Image.Image.blur_avg_filter"><code class="name flex">
<span>def <span class="ident">blur_avg_filter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to apply averaging filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blur_avg_filter(self):
    &#34;&#34;&#34;
        function to apply averaging filter
    &#34;&#34;&#34;
    self._update_img(self.Avaraging.apply(self.tmp_image))</code></pre>
</details>
</dd>
<dt id="Image.Image.blur_bilateral_filter"><code class="name flex">
<span>def <span class="ident">blur_bilateral_filter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to apply bilateral filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blur_bilateral_filter(self):
    &#34;&#34;&#34;
        function to apply bilateral filter
    &#34;&#34;&#34;
    self._update_img(self.Bilateral.apply(self.tmp_image))</code></pre>
</details>
</dd>
<dt id="Image.Image.blur_gauss_filter"><code class="name flex">
<span>def <span class="ident">blur_gauss_filter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to apply gaussian filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blur_gauss_filter(self):
    &#34;&#34;&#34;
        function to apply gaussian filter
    &#34;&#34;&#34;
    self._update_img(self.Gaussian.apply(self.tmp_image))</code></pre>
</details>
</dd>
<dt id="Image.Image.blur_med_filter"><code class="name flex">
<span>def <span class="ident">blur_med_filter</span></span>(<span>self, params_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>function to apply median filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blur_med_filter(self,params_dict):
    &#34;&#34;&#34;
        function to apply median filter
    &#34;&#34;&#34;
    self._update_img(self.Median.apply(self.tmp_image))</code></pre>
</details>
</dd>
<dt id="Image.Image.delete_mask"><code class="name flex">
<span>def <span class="ident">delete_mask</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>function to delete mask given by name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_mask(self, name):
    &#34;&#34;&#34;
    function to delete mask given by name.
    &#34;&#34;&#34;
    default_mask = self.masks[self.default_mask_name]
    if self.active_mask == default_mask:
        default_mask = deepcopy(self.active_mask)
        default_mask.saved = False
        self.masks[self.default_mask_name] = default_mask
        
    self.mask_belongings[self.active_mask.get(modified=False)] = MaskBelonging.NONE
    self.masks.pop(name)
    self.masks_mapping.pop(self.active_mask.id)
    self._update_all_masks()</code></pre>
</details>
</dd>
<dt id="Image.Image.img_loaded"><code class="name flex">
<span>def <span class="ident">img_loaded</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Image.Image.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to load an image from destination and reset some Image object values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self):
    &#34;&#34;&#34;
    function to load an image from destination and reset some Image object values
    &#34;&#34;&#34;
    file_name = QFileDialog.getOpenFileName(None, &#34;Open File&#34;, &#34;/home&#34;, &#34;Images (*.png *.xpm *.jpg)&#34;)[0]
    if file_name:
        self.graphic_area.setScaledContents(True)
        self.image = cv.imread(file_name, cv.IMREAD_GRAYSCALE)
        self.thresholded_pixels = np.full((self.image.shape[0], self.image.shape[1]), False, dtype=bool)
        self.mask_belongings = np.full((self.image.shape[0], self.image.shape[1]), MaskBelonging.NONE, dtype=int)
        self.tmp_image = self.image
        self._update_img(self.image)
        if not self.masks:
            self.new_mask()
        else:
            self._update_all_masks(update_threshold=True)
            self.show_curr_mask()
        # was call to new here
        self.img_loaded.emit()</code></pre>
</details>
</dd>
<dt id="Image.Image.load_mask"><code class="name flex">
<span>def <span class="ident">load_mask</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>function to load mask given by name. Some values are reset in case new image was loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_mask(self, name):
    &#34;&#34;&#34;
    function to load mask given by name. Some values are reset in case new image was loaded.
    &#34;&#34;&#34;
    self.active_mask.is_read = False
    self.active_mask = self.masks.get(name)
    self.active_mask.loaded_handler()
    self.mask_loaded.emit(self.active_mask)
    self.show_curr_mask()
    if(not self.active_mask.new):
        self.active_mask.is_read = True</code></pre>
</details>
</dd>
<dt id="Image.Image.mask_loaded"><code class="name flex">
<span>def <span class="ident">mask_loaded</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Image.Image.mask_saved"><code class="name flex">
<span>def <span class="ident">mask_saved</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Image.Image.new_mask"><code class="name flex">
<span>def <span class="ident">new_mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to create a new mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_mask(self):
    &#34;&#34;&#34;
    function to create a new mask.
    &#34;&#34;&#34;
    if self.active_mask:
        self.active_mask.is_read = False
    self.active_mask = Mask(self.image.shape[0], self.image.shape[1])
    self.masks[self.default_mask_name] = self.active_mask
    self.mask_loaded.emit(self.active_mask)
    self.show_curr_img()</code></pre>
</details>
</dd>
<dt id="Image.Image.not_thresholded_handler"><code class="name flex">
<span>def <span class="ident">not_thresholded_handler</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to show which pixels haven't been thresholded yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_thresholded_handler(self):
    &#34;&#34;&#34;
    function to show which pixels haven&#39;t been thresholded yet.
    &#34;&#34;&#34;
    blue_x, blue_y = np.where(self.thresholded_pixels == False)
    mask_img = self._create_mask_img(blue_x, blue_y, MaskColor.BLUE)
    self._show_img(mask_img)</code></pre>
</details>
</dd>
<dt id="Image.Image.pixel_clicked_handler"><code class="name flex">
<span>def <span class="ident">pixel_clicked_handler</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>function to add pixel to current mask pixel list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixel_clicked_handler(self, x, y):
    &#34;&#34;&#34;
    function to add pixel to current mask pixel list.
    &#34;&#34;&#34;
    img_x, img_y = self._transform_pixel_to_img(x, y)
    grey_value = self.image[img_y][img_x]
    self.pixel_selected.emit(grey_value)
    self.active_mask.add_pixel(grey_value)</code></pre>
</details>
</dd>
<dt id="Image.Image.pixel_selected"><code class="name flex">
<span>def <span class="ident">pixel_selected</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Image.Image.pop_mask_pixel"><code class="name flex">
<span>def <span class="ident">pop_mask_pixel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to pop a pixel from a current mask pixel list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_mask_pixel(self):
    &#34;&#34;&#34;
    function to pop a pixel from a current mask pixel list.
    &#34;&#34;&#34;
    
    try : 
        prev_mask = self.active_mask.get(modified=False)
        self.active_mask.pop_pixel()
        self.apply_mask(prev_mask)
    except IndexError as err:
        QMessageBox.information(self.graphic_area, &#34;Error&#34;,  err.args[0])
    except AttributeError as err:
        QMessageBox.information(self.graphic_area, &#34;Error&#34;, &#34;Mask hasn&#39;t been created yet.&#34;)</code></pre>
</details>
</dd>
<dt id="Image.Image.remove_threshold"><code class="name flex">
<span>def <span class="ident">remove_threshold</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>remove thresolding from image, if it have not been applied before</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_threshold(self):
    &#34;&#34;&#34;
        remove thresolding from image, if it have not been applied before
    &#34;&#34;&#34;
    self.thresh_val_calc.emit(0)
    if not self.active_mask.is_thresholded:
        self._update_img(self.mask_copy)
    else:
        self.active_mask.is_thresholded = True</code></pre>
</details>
</dd>
<dt id="Image.Image.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to save current image. If not every pixel was thresholded, question
occurs whether user wants to continue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
    &#34;&#34;&#34;
    function to save current image. If not every pixel was thresholded, question
    occurs whether user wants to continue.
    &#34;&#34;&#34;
    if not self._empty_img_error():
        if not np.all(self.thresholded_pixels):
            reply = QMessageBox.question(self.graphic_area, &#34;Work not finished&#34;, &#34;Are you sure you want to save the image ? Some pixels haven&#39;t been thresholded yet.&#34;)
            if reply == QMessageBox.Yes:
                destination = QFileDialog.getSaveFileName(filter=&#34;Image (*.jpg *.png)&#34;)[0]
                cv.imwrite(destination,self.tmp_image)        
        else:
            destination = QFileDialog.getSaveFileName(filter=&#34;Image (*.jpg *.png)&#34;)[0]
            cv.imwrite(destination,self.tmp_image)</code></pre>
</details>
</dd>
<dt id="Image.Image.save_mask"><code class="name flex">
<span>def <span class="ident">save_mask</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>function to save curr mask as a given name. If the name was provided before, warning occurs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_mask(self, name):
    &#34;&#34;&#34;
    function to save curr mask as a given name. If the name was provided before, warning occurs.
    &#34;&#34;&#34;
    if name in self.masks.keys():
        QMessageBox.warning(self.graphic_area,&#34;Error&#34;,&#34;Mask with such name already exist.&#34;)
    else:
        self.mask_belongings[self.active_mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels)] = self.active_mask.id
        self.masks_mapping[self.active_mask.id] = name
        self.masks[name] = self.active_mask
        self.active_mask.saved = True
        self.mask_saved.emit(name)</code></pre>
</details>
</dd>
<dt id="Image.Image.show_curr_img"><code class="name flex">
<span>def <span class="ident">show_curr_img</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to show curr img</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_curr_img(self):
    &#34;&#34;&#34;
    function to show curr img
    &#34;&#34;&#34;
    frame = cv.cvtColor(self.tmp_image, cv.COLOR_BGR2RGB)
    self._show_img(frame)</code></pre>
</details>
</dd>
<dt id="Image.Image.show_curr_mask"><code class="name flex">
<span>def <span class="ident">show_curr_mask</span></span>(<span>self, modified=True)</span>
</code></dt>
<dd>
<div class="desc"><p>function to show the current mask = last that was applied</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_curr_mask(self, modified = True):
    &#34;&#34;&#34;
    function to show the current mask = last that was applied
    &#34;&#34;&#34;
    red_rows, red_columns = np.where(self.active_mask.get(self.tmp_image, self.mask_belongings, self.thresholded_pixels, modified) == False)
    mask_img = self._create_mask_img(red_rows, red_columns, MaskColor.RED)
    self._show_img(mask_img)</code></pre>
</details>
</dd>
<dt id="Image.Image.thresh_val_calc"><code class="name flex">
<span>def <span class="ident">thresh_val_calc</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Image.Image.threshold"><code class="name flex">
<span>def <span class="ident">threshold</span></span>(<span>self, method='VAL')</span>
</code></dt>
<dd>
<div class="desc"><p>set thresolding to given value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def threshold(self,method=&#39;VAL&#39;):
    &#34;&#34;&#34;
        set thresolding to given value
    &#34;&#34;&#34;
    self.mask_copy=np.copy(self.tmp_image)
    indexes_to_thr=np.where(self.active_mask.get(modified=False))
    otsu_res,thres_val=self.Otsu.apply(self.mask_copy[indexes_to_thr],method)
    self.tmp_image[tuple((indexes_to_thr))]=otsu_res.flatten()
    self.latest_img=self.tmp_image.copy()
    self._update_img(self.tmp_image)
    self.thresh_val_calc.emit(thres_val)
    self.tmp_image=self.mask_copy</code></pre>
</details>
</dd>
<dt id="Image.Image.update_mask_pixel_tol"><code class="name flex">
<span>def <span class="ident">update_mask_pixel_tol</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>function to update pixel tolerance in current mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_mask_pixel_tol(self, value):
    &#34;&#34;&#34;
    function to update pixel tolerance in current mask.
    &#34;&#34;&#34;
    prev_mask = self.active_mask.get(modified=False)
    self.active_mask.update_pixel_tol(value)
    self.apply_mask(prev_mask)</code></pre>
</details>
</dd>
<dt id="Image.Image.update_slider_mask"><code class="name flex">
<span>def <span class="ident">update_slider_mask</span></span>(<span>self, s_min, s_max, s_tol)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_slider_mask(self, s_min, s_max, s_tol):
    prev_mask = self.active_mask.get(modified=False)
    self.active_mask.update_slider_mask(s_min, s_max, s_tol)
    self.apply_mask(prev_mask)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Image.Image" href="#Image.Image">Image</a></code></h4>
<ul class="">
<li><code><a title="Image.Image.apply_mask" href="#Image.Image.apply_mask">apply_mask</a></code></li>
<li><code><a title="Image.Image.apply_threshold" href="#Image.Image.apply_threshold">apply_threshold</a></code></li>
<li><code><a title="Image.Image.blur_avg_filter" href="#Image.Image.blur_avg_filter">blur_avg_filter</a></code></li>
<li><code><a title="Image.Image.blur_bilateral_filter" href="#Image.Image.blur_bilateral_filter">blur_bilateral_filter</a></code></li>
<li><code><a title="Image.Image.blur_gauss_filter" href="#Image.Image.blur_gauss_filter">blur_gauss_filter</a></code></li>
<li><code><a title="Image.Image.blur_med_filter" href="#Image.Image.blur_med_filter">blur_med_filter</a></code></li>
<li><code><a title="Image.Image.delete_mask" href="#Image.Image.delete_mask">delete_mask</a></code></li>
<li><code><a title="Image.Image.img_loaded" href="#Image.Image.img_loaded">img_loaded</a></code></li>
<li><code><a title="Image.Image.load" href="#Image.Image.load">load</a></code></li>
<li><code><a title="Image.Image.load_mask" href="#Image.Image.load_mask">load_mask</a></code></li>
<li><code><a title="Image.Image.mask_loaded" href="#Image.Image.mask_loaded">mask_loaded</a></code></li>
<li><code><a title="Image.Image.mask_saved" href="#Image.Image.mask_saved">mask_saved</a></code></li>
<li><code><a title="Image.Image.new_mask" href="#Image.Image.new_mask">new_mask</a></code></li>
<li><code><a title="Image.Image.not_thresholded_handler" href="#Image.Image.not_thresholded_handler">not_thresholded_handler</a></code></li>
<li><code><a title="Image.Image.pixel_clicked_handler" href="#Image.Image.pixel_clicked_handler">pixel_clicked_handler</a></code></li>
<li><code><a title="Image.Image.pixel_selected" href="#Image.Image.pixel_selected">pixel_selected</a></code></li>
<li><code><a title="Image.Image.pop_mask_pixel" href="#Image.Image.pop_mask_pixel">pop_mask_pixel</a></code></li>
<li><code><a title="Image.Image.remove_threshold" href="#Image.Image.remove_threshold">remove_threshold</a></code></li>
<li><code><a title="Image.Image.save" href="#Image.Image.save">save</a></code></li>
<li><code><a title="Image.Image.save_mask" href="#Image.Image.save_mask">save_mask</a></code></li>
<li><code><a title="Image.Image.show_curr_img" href="#Image.Image.show_curr_img">show_curr_img</a></code></li>
<li><code><a title="Image.Image.show_curr_mask" href="#Image.Image.show_curr_mask">show_curr_mask</a></code></li>
<li><code><a title="Image.Image.thresh_val_calc" href="#Image.Image.thresh_val_calc">thresh_val_calc</a></code></li>
<li><code><a title="Image.Image.threshold" href="#Image.Image.threshold">threshold</a></code></li>
<li><code><a title="Image.Image.update_mask_pixel_tol" href="#Image.Image.update_mask_pixel_tol">update_mask_pixel_tol</a></code></li>
<li><code><a title="Image.Image.update_slider_mask" href="#Image.Image.update_slider_mask">update_slider_mask</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>